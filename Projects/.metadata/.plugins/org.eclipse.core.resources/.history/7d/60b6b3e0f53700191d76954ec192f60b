#include "TutorialApplication.h"
#include "EntityMgr.h"
#include "Renderable.h"

TutorialApplication::TutorialApplication(void)
{
}

TutorialApplication::~TutorialApplication(void)
{
}

//GLOBAL VARIABLES
EntityMgr* entMgr;
const float surfaceHeight = -120.0;
//*****************

void TutorialApplication::createScene(void)
{
	mSceneMgr->setAmbientLight(Ogre::ColourValue(0.5,0.5,0.5));
	//mSceneMgr->setShadowTechnique(Ogre::SHADOWTYPE_STENCIL_MODULATIVE);

	mCamera->lookAt(0,0,0);

	Ogre::Light* light = mSceneMgr->createLight("mainLight");
	light->setPosition(20,80,50);

	makeGround();
	makeSky();

	entMgr = new EntityMgr(mSceneMgr);
	makeEntities();


}

bool TutorialApplication::frameRenderingQueued(const Ogre::FrameEvent& fe)
{
	if(!processUnbufferedInput(fe))
		return false;
	if(mKeyboard->isKeyDown(OIS::KC_Q))
		return false;

	entMgr->Tick(fe.timeSinceLastFrame);


	return BaseApplication::frameRenderingQueued(fe);
}




bool TutorialApplication::processUnbufferedInput(const Ogre::FrameEvent& fe)
{
	static float toggleTimer = 0.0;
	static const float moveConst = 5.0;
	static const float rotConst = 0.01;
	static float rotSpeed = 0;
	Ogre::Vector3* velocity = new Ogre::Vector3(0,0,0);
	Ogre::Vector3 camVec = Ogre::Vector3::ZERO;

	toggleTimer -= fe.timeSinceLastFrame;
	if(mKeyboard->isKeyDown(OIS::KC_TAB) && toggleTimer < 0)//select entity
	{
		entMgr->enumerateIndex();
		toggleTimer = 0.2;
	}

	if(mKeyboard->isKeyDown(OIS::KC_I) && toggleTimer < 0)//entity move forward
	{
		Physics *temp = (Physics*) entMgr->getEntity()->getAspect(1);
		velocity = temp->getVelocity();

		velocity->z += moveConst;

		temp->setVelocity(*velocity);
		toggleTimer = 0.2;
	}
	if(mKeyboard->isKeyDown(OIS::KC_J) && toggleTimer < 0)//entity move left
	{
		Physics *temp = (Physics*) entMgr->getEntity()->getAspect(1);
		velocity = temp->getVelocity();

		velocity->x -= moveConst;

		temp->setVelocity(*velocity);
		toggleTimer = 0.2;
	}
	if(mKeyboard->isKeyDown(OIS::KC_K) && toggleTimer < 0)//entity move back
	{
		Physics *temp = (Physics*) entMgr->getEntity()->getAspect(1);
		velocity = temp->getVelocity();

		velocity->z -= moveConst;

		temp->setVelocity(*velocity);
		toggleTimer = 0.2;
	}
	if(mKeyboard->isKeyDown(OIS::KC_L) && toggleTimer < 0)//entity move right
	{
		Physics *temp = (Physics*) entMgr->getEntity()->getAspect(1);
		velocity = temp->getVelocity();

		velocity->x -= moveConst;

		temp->setVelocity(*velocity);
		toggleTimer = 0.2;
	}
	if(mKeyboard->isKeyDown(OIS::KC_U) && toggleTimer < 0)//entity move up
	{
		Physics *temp = (Physics*) entMgr->getEntity()->getAspect(1);
		velocity = temp->getVelocity();

		velocity->y += moveConst;

		temp->setVelocity(*velocity);
		toggleTimer = 0.2;
	}
	if(mKeyboard->isKeyDown(OIS::KC_O) && toggleTimer < 0)//entity move down
	{
		Physics *temp = (Physics*) entMgr->getEntity()->getAspect(1);
		velocity = temp->getVelocity();

		velocity->y -= moveConst;

		temp->setVelocity(*velocity);
		toggleTimer = 0.2;
	}

	if(mKeyboard->isKeyDown(OIS::KC_N) && toggleTimer < 0)//entity rotation up
	{
		Rotator *temp = (Rotator*) entMgr->getEntity()->getAspect(2);
		rotSpeed = temp->getRotationSpeed();

		rotSpeed += moveConst;

		temp->setRotationSpeed(rotSpeed);
		toggleTimer = 0.2;
	}
	if(mKeyboard->isKeyDown(OIS::KC_M) && toggleTimer < 0)//entity rotation down
	{
		Rotator *temp = (Rotator*) entMgr->getEntity()->getAspect(2);
		rotSpeed = temp->getRotationSpeed();

		rotSpeed -= moveConst;

		temp->setRotationSpeed(rotSpeed);
		toggleTimer = 0.2;
	}

	if(mKeyboard->isKeyDown(OIS::KC_SPACE) && toggleTimer < 0)//halt entity
	{
		Rotator *rtemp = (Rotator*) entMgr->getEntity()->getAspect(2);
		rtemp->setRotationSpeed(0);

		Physics *ptemp = (Physics*) entMgr->getEntity()->getAspect(1);
		ptemp->setVelocity(Ogre::Vector3::ZERO);
		toggleTimer = 0.2;
	}

	//Camera Controls
	if(mKeyboard->isKeyDown(OIS::KC_E))//camera up
	{
		camVec = mCamera->getPosition();
		camVec.y += 0.5;
		mCamera->setPosition(camVec);
	}
	if(mKeyboard->isKeyDown(OIS::KC_F))//camera down
	{
		camVec = mCamera->getPosition();
		camVec.y -= 0.5;
		mCamera->setPosition(camVec);
	}

	if(mKeyboard->isKeyDown(OIS::KC_LSHIFT))
	{
		if(mKeyboard->isKeyDown(OIS::KC_A))
		{
			mCamera->getParentSceneNode()->yaw(Ogre::Degree(5));
		}
		else if(mKeyboard->isKeyDown(OIS::KC_D))
		{
			mCamera->getParentSceneNode()->yaw(Ogre::Degree(-5));
		}

	}



	return true;
}

void TutorialApplication::makeEntities()
{
	int spacing = 300;
	for(int i=0 ; i<5 ; i++)
		entMgr->createEntity(true, "cube" + i, Ogre::Vector3(i*spacing,0,0));

	for(int i=0 ; i<5 ; i++)
		entMgr->createEntity(false, "sphere" + i, Ogre::Vector3(i*spacing,0,spacing));
}

void TutorialApplication::makeGround()
{
	//create the plane
		Ogre::Plane plane(Ogre::Vector3::UNIT_Y, 0);
		Ogre::MeshManager::getSingleton().createPlane(
				"ground", Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, //region name
				plane, //plane object
				10000, 10000, 20, 20, //dimensions?
				true, //toggle normal?
				1, 5, 5, //uv coordinate stuff
				Ogre::Vector3::UNIT_Z //normal vector
		);

		//attach ground to the scene
		Ogre::SceneNode* floorNode = mSceneMgr->getRootSceneNode()->createChildSceneNode();
		Ogre::Entity* floorEnt = mSceneMgr->createEntity("ground");
		floorNode->setPosition(Ogre::Vector3(0, surfaceHeight, 0));
		floorNode->attachObject(floorEnt);
		floorEnt->setCastShadows(false);
		floorEnt->setMaterialName("Examples/Rockwall");
}

void TutorialApplication::makeSky()
{
	mSceneMgr->setSkyBox(true, "Examples/StormySkyBox");
}


#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
    INT WINAPI WinMain(HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT)
#else
    int main(int argc, char *argv[])
#endif
    {
	// Create application object
	TutorialApplication app;

	try {
	    app.go();
	} catch(Ogre::Exception& e)  {
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
	    MessageBox(NULL, e.getFullDescription().c_str(), "An exception has occurred!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
	    std::cerr << "An exception has occurred: " <<
		e.getFullDescription().c_str() << std::endl;
#endif
	}

	return 0;
    }

#ifdef __cplusplus
}
#endif
